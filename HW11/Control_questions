1. Идеальная передача сохраняет фундаментальные свойства (одно из следующих): 
1) Константность (const X &);
2) Модифицируемость (X &); 
3) Перемещаемость (X &&). 

Реализуется идеальная передача с помощью семантики
перемещений в шаблонах (в данном случае f->g):
template < typename T > 
void f(T && v) { g(std::forward < T > (v)); } 
Выражение в теле функции и обеспечивает идеальную передачу.

2. Пример использования пробрасывающей ссылки (forwarding reference) приведён в куске кода из прошлого вопроса. Она позволяет не дублировать 
код функции для случаев l-value и r-value ссылок, с помощью std::forward проводя УСЛОВНОЕ (то есть не изменяя фундаментальных свойств объекта) 
приведение к r-value ссылке.

Как отличить r-value ссылку от пробрасывающей?
X && - r-value
T && - forwarding
auto && - forwarding.

3. 

