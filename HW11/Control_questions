1. Идеальная передача сохраняет фундаментальные свойства (одно из следующих): 
1) Константность (const X &);
2) Модифицируемость (X &); 
3) Перемещаемость (X &&). 

Реализуется идеальная передача с помощью семантики
перемещений в шаблонах (в данном случае f->g):
template < typename T > 
void f(T && v) { g(std::forward < T > (v)); } 
Выражение в теле функции и обеспечивает идеальную передачу.

2. Пример использования пробрасывающей ссылки (forwarding reference) приведён в куске кода из прошлого вопроса. Она позволяет не дублировать 
код функции для случаев l-value и r-value ссылок, с помощью std::forward проводя УСЛОВНОЕ (то есть не изменяя фундаментальных свойств объекта) 
приведение к r-value ссылке.

Как отличить r-value ссылку от пробрасывающей?
X && - r-value
T && - forwarding
auto && - forwarding.

3. Идиома SFINAE (substitution failure is not an error, ошибка подстановки не является ошибкой) применительно к щаблонам заключается в том,
что если конструкция std::enable_if < Condition > сработает как False применительно к какому-то шаблону, не произойдёт ошибки компиляции, 
а будет осуществляться поиск другой подходящей альтернативы.

4. Шаблон std::enable_if < Condition > можно использовать для объяснения компилятору, в каком случае следует использовать данный шаблон.
В случае, если Condition = True, им возвращается void и шаблон компилируется, в случае, если Condition = False, возвращается "пустое место"
и компилятор начинает поиск подходящей альтернативы.

5. 

