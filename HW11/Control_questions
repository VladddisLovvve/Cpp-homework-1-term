1. Идеальная передача сохраняет фундаментальные свойства (одно из следующих): 
1) Константность (const X &);
2) Модифицируемость (X &); 
3) Перемещаемость (X &&). 

Реализуется идеальная передача с помощью семантики
перемещений в шаблонах (в данном случае f->g):
template < typename T > 
void f(T && v) { g(std::forward < T > (v)); } 
Выражение в теле функции и обеспечивает идеальную передачу.

2. Пример использования пробрасывающей ссылки (forwarding reference) приведён в куске кода из прошлого вопроса. Она позволяет не дублировать 
код функции для случаев l-value и r-value ссылок, с помощью std::forward проводя УСЛОВНОЕ (то есть не изменяя фундаментальных свойств объекта) 
приведение к r-value ссылке.

Как отличить r-value ссылку от пробрасывающей?
X && - r-value
T && - forwarding
auto && - forwarding.

3. Идиома SFINAE (substitution failure is not an error, ошибка подстановки не является ошибкой) применительно к щаблонам заключается в том,
что если конструкция std::enable_if < Condition > сработает как False применительно к какому-то шаблону, не произойдёт ошибки компиляции, 
а будет осуществляться поиск другой подходящей альтернативы.

4. Шаблон std::enable_if < Condition > можно использовать для объяснения компилятору, в каком случае следует использовать данный шаблон.
В случае, если Condition = True, им возвращается void и шаблон компилируется, в случае, если Condition = False, возвращается "пустое место"
и компилятор начинает поиск подходящей альтернативы.

5. Как можно передать аргумента шаблону функции:
1. По значению - в базовом шаблоне считается предпочтительнее использование передачи аргумента по значению (копирование). Это является оптимальным,
так как обычно используются фундаментальные типы, а если они не фундаментальны, компилятор сам производит оптимизацию, реализуя
семинатику перемещений. Также, пользуясь обёрткой std::cref или std::ref в вызове функции можно обеспечить ссылочную передачу аргумента;
2. По ссылке - является оптимальнее для нефундаментальных типов в виду повышения производительности (так как копирование не производится). Возможна 
модифицируемость объекта, если он передаётся по неконстантой ссылке. Пробрасывающие ссылки превращаются в l-value или r-value в зависимости от 
передаваемого аргумента.
Для ссылок имеет смысл рассмотреть правила их свёртывания:
& &, && &, & && преобразется к & (l-value ссылке)
&& преобразуется к && (r-value ссылке)

Правила вывода для пробрасывающей ссылки:
template < typename T >
void f(T && arg)
int x = 12; T = int &, arg - int & && - int &;
const int cx = 12; T = const int &, arg - const int & && - const int &;
const int & rx = cx; T = const int &, arg - const int & &&  - const int &;
f(12); T = int, arg = int &&
f(std::move(x)), T = int &&, arg - int && && - int &&
То есть фактически к типу Т навешивается && и используются правила свёртывания ссылок. 
