1. Основные варианты отношений между классами:
1) Композиция - А часть Б, под упрвлением Б, не знает о Б;
2) Агрегация - А часть Б1, Б2, ..., не управляется ими, не знает их;
3) Ассоциация - независимые объекты, используют друг друга;
4) Зависимость - использование без хранения связи с объектом.

2. Существуют следующие разновидности наследования:
1) Публичное (public, наследование интерфейсов) - потомок содержит все функции-члены предка; public наследуется как public, protected наследуется как protected, private не наследуется;
2) Приватное (private, наследование реализаций) - потомок наследует только реализацию; public наследуется как private, protected наследуется как private, private не наследуется;
3) Защищенное (protected) - потомки потомка наследуют реализацию своего прапредка; public наследуется как protected, protected как protected, private не наследуется.

3. Для корректного функционирования механизма виртуальных функций:
1) Требуется наследование;
2) Требуется ключевое слово virtual/override/final;
3) Полное совпадение сигнатур функций;
4) Доступ к экземплярам через указатели * или ссылки &
Важно, что виртуальные функции нельзя использовать в конструкторах и деструкторах 

4. Виртуальные базовые классы при множественном наследовании решают проблему неоднозначного выбора между общими данными: если от базового класса B наследуются Д1 и Д2, 
а Д12 общий потомок для Д1 и Д2, то Д12 имеет доступ к данными от Д1 и от Д2. В свою очередь эти данные наследованы от независимых отностельно Д1 и Д2 классов В, 
что порождает неоднозначный выбор. 
Виртуальный класс указывает, что Д1 и Д2 будут наследоваться не независимо, таким образом через Д12 можно иметь доступ к данным В через Д1 и Д2.

В       B                         В
|       |                        / \
Д1     Д2  - это плохо         Д1   Д2  - это хорошо
  \   /                          \ /
   Д12                           Д12
   
5. Основные каттегории паттернов проектирования:
1) Порождающие - не вносят новых взаимосвязей между уже существующими объектами, но позволяют сделать её независимой от типов объектов и самих объектов (factory.cpp); 
2) Структурные - используются для построения связей между объектами (adapter.cpp);
3) Поведенческие - паттерны, определяющие алгоритмы и варианты реализации взаимодействий разных объектов (template_method.cpp).

